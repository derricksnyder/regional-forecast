<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- Essential for responsive behavior on all devices -->
    <title>NWS Regional 6-Day Forecast Dashboard</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- html2canvas library for generating images -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; /* Light gray background */
        }
        .card {
            background-color: #ffffff;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s ease-in-out;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }
        .card:hover {
            transform: translateY(-5px);
        }
        .loading-spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #3b82f6; /* Blue spinner */
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .weather-icon {
            width: 128px; /* Increased size for better visibility on mobile */
            height: 128px; /* Increased size for better visibility on mobile */
            object-fit: contain;
        }
        .regional-forecast-card {
            grid-column: 1 / -1; /* Span all columns in the grid */
            background-color: #e0f2f7; /* Light blue background */
            border: 2px solid #0288d1; /* Darker blue border */
            padding: 1.5rem;
            margin-bottom: 1.5rem;
        }
        /* Modal styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: white;
            padding: 2rem;
            border-radius: 12px;
            max-width: 90%;
            max-height: 90vh;
            overflow-y: auto;
        }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center p-4"> <!-- p-4 adds padding on all sides for mobile -->

    <div class="container mx-auto p-6 bg-blue-600 text-white rounded-lg shadow-lg mb-8 max-w-6xl text-center">
        <h1 class="text-3xl font-bold mb-2">NWS Regional 6-Day Forecast Dashboard</h1>
        <p class="text-lg">Averaged weather outlook for key locations in the NWS Paducah area.</p>
        <p id="lastUpdated" class="text-sm mt-2"></p>
        <!-- Generate Image Button -->
        <button id="generateImageBtn" class="mt-4 px-4 py-2 bg-white text-blue-600 font-semibold rounded-lg shadow-md hover:bg-blue-100 focus:outline-none focus:ring-2 focus:ring-blue-400 focus:ring-opacity-75">
            Generate Image
        </button>
    </div>

    <div id="loadingIndicator" class="flex flex-col items-center justify-center p-8">
        <div class="loading-spinner"></div>
        <p class="mt-4 text-gray-700 text-lg">Fetching regional forecast data...</p>
    </div>

    <div id="errorMessage" class="hidden bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative max-w-4xl w-full" role="alert">
        <strong class="font-bold">Error!</strong>
        <span class="block sm:inline" id="errorText"></span>
    </div>

    <div id="forecastContainer" class="hidden w-full max-w-6xl"> <!-- w-full ensures it takes full width on mobile -->
        <div id="forecastGrid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6">
            <!-- Forecast cards will be dynamically inserted here -->
        </div>
    </div>

    <!-- Modal for displaying the generated image -->
    <div id="imageModal" class="modal-overlay hidden">
        <div class="modal-content">
            <h2 class="text-2xl font-bold mb-4">Generated Forecast Image</h2>
            <p class="mb-4 text-gray-600">Right-click the image to copy or save it. You can paste it directly into Google Slides.</p>
            <div id="imageOutput" class="mb-4 border p-2 rounded-lg">
                <!-- Generated image will be placed here -->
            </div>
            <div class="flex justify-end">
                <button id="closeModalBtn" class="px-4 py-2 bg-gray-600 text-white font-semibold rounded-lg shadow-md hover:bg-gray-700">Close</button>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Configuration: Locations for Averaging ---
            const locations = [
                { name: 'Marion, IL', lat: 37.730278, lon: -88.928889 },
                { name: 'Paducah, KY', lat: 37.0848, lon: -88.5980 },
                { name: 'Owensboro, KY', lat: 37.757778, lon: -87.118333 },
                { name: 'Evansville, IN', lat: 37.977222, lon: -87.550552 },
                { name: 'Poplar Bluff, MO', lat: 36.763333, lon: -90.413611 },
                { name: 'Cape Girardeau, MO', lat: 37.309444, lon: -89.538889 },
                { name: 'Mount Vernon, IL', lat: 38.317222, lon: -88.917222 }
            ];

            const loadingIndicator = document.getElementById('loadingIndicator');
            const errorMessage = document.getElementById('errorMessage');
            const errorText = document.getElementById('errorText');
            const forecastContainer = document.getElementById('forecastContainer');
            const forecastGrid = document.getElementById('forecastGrid');
            const generateImageBtn = document.getElementById('generateImageBtn');
            const imageModal = document.getElementById('imageModal');
            const imageOutput = document.getElementById('imageOutput');
            const closeModalBtn = document.getElementById('closeModalBtn');

            const allLocationsForecastData = [];

            const US_FEDERAL_HOLIDAYS = {
                '01-01': 'New Year\'s Day', '06-19': 'Juneteenth', '07-04': 'Independence Day',
                '11-11': 'Veterans Day', '12-25': 'Christmas Day',
                'mlk': { month: 0, dayOfWeek: 1, week: 3, name: 'Martin Luther King, Jr.\'s Birthday' },
                'presidents': { month: 1, dayOfWeek: 1, week: 3, name: 'Washington\'s Birthday' },
                'memorial': { month: 4, dayOfWeek: 1, week: 'last', name: 'Memorial Day' },
                'labor': { month: 8, dayOfWeek: 1, week: 1, name: 'Labor Day' },
                'columbus': { month: 9, dayOfWeek: 1, week: 2, name: 'Columbus Day' },
                'thanksgiving': { month: 10, dayOfWeek: 4, week: 4, name: 'Thanksgiving Day' }
            };

            const isFederalHoliday = (date) => {
                const month = date.getMonth();
                const day = date.getDate();
                const year = date.getFullYear();
                const dayOfWeek = date.getDay();

                const fixedDateKey = `${(month + 1).toString().padStart(2, '0')}-${day.toString().padStart(2, '0')}`;
                if (US_FEDERAL_HOLIDAYS[fixedDateKey]) return US_FEDERAL_HOLIDAYS[fixedDateKey];

                for (const key in US_FEDERAL_HOLIDAYS) {
                    const holidayRule = US_FEDERAL_HOLIDAYS[key];
                    if (typeof holidayRule === 'object' && holidayRule.month === month) {
                        if (holidayRule.week === 'last') {
                            const lastDayOfMonth = new Date(year, month + 1, 0);
                            let testDate = new Date(year, month, lastDayOfMonth.getDate());
                            while (testDate.getDay() !== holidayRule.dayOfWeek) {
                                testDate.setDate(testDate.getDate() - 1);
                            }
                            if (testDate.getDate() === day) return holidayRule.name;
                        } else {
                            let count = 0;
                            for (let d = 1; d <= 31; d++) {
                                const testDate = new Date(year, month, d);
                                if (testDate.getMonth() !== month) break;
                                if (testDate.getDay() === holidayRule.dayOfWeek) {
                                    count++;
                                    if (count === holidayRule.week && testDate.getDate() === day) return holidayRule.name;
                                }
                            }
                        }
                    }
                }
                return null;
            };

            const formatDate = (dateString, isFirstPeriod) => {
                const date = new Date(dateString);
                const now = new Date();
                const isToday = date.getDate() === now.getDate() &&
                                date.getMonth() === now.getMonth() &&
                                date.getFullYear() === now.getFullYear();

                const holidayName = isFederalHoliday(date);

                if (holidayName) {
                    return holidayName;
                } else if (isToday && isFirstPeriod) {
                    return 'Today';
                } else {
                    return date.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' });
                }
            };

            const getMostFrequent = (arr) => {
                if (!arr || arr.length === 0) return null;
                const hashmap = arr.reduce((acc, val) => {
                    acc[val] = (acc[val] || 0) + 1;
                    return acc;
                }, {});
                return Object.keys(hashmap).reduce((a, b) => hashmap[a] > hashmap[b] ? a : b);
            };
            
            const parseNumericalValue = (valueString) => {
                const trimmedValue = String(valueString).trim();
                if (trimmedValue === 'null' || trimmedValue === '') return null;
                const parsed = parseFloat(trimmedValue);
                return isNaN(parsed) ? null : parsed;
            };

            async function fetchAndParseLocationForecast(location) {
                const forecastUrl = `https://forecast.weather.gov/MapClick.php?lat=${location.lat}&lon=${location.lon}&unit=0&lg=english&FcstType=dwml`;
                try {
                    const response = await fetch(forecastUrl);
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    const xmlText = await response.text();
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(xmlText, "text/xml");

                    if (xmlDoc.getElementsByTagName("parsererror").length > 0) {
                        throw new Error(`Error parsing XML for ${location.name}.`);
                    }

                    const timeLayouts = {};
                    xmlDoc.querySelectorAll('time-layout').forEach(layout => {
                        const layoutKey = layout.querySelector('layout-key').textContent;
                        timeLayouts[layoutKey] = {
                            startTimes: Array.from(layout.querySelectorAll('start-valid-time')).map(t => t.textContent),
                            endTimes: Array.from(layout.querySelectorAll('end-valid-time')).map(t => t.textContent),
                            summaries: Array.from(layout.querySelectorAll('layout-summary')).map(s => s.textContent)
                        };
                    });

                    const parameters = xmlDoc.querySelector('parameters');
                    if (!parameters) throw new Error(`Could not find forecast parameters for ${location.name}.`);
                    
                    const maxTemps = parameters.querySelector('temperature[type="maximum"]');
                    const minTemps = parameters.querySelector('temperature[type="minimum"]');
                    const maxTempValues = maxTemps ? Array.from(maxTemps.querySelectorAll('value')).map(v => v.textContent) : [];
                    const minTempValues = minTemps ? Array.from(minTemps.querySelectorAll('value')).map(v => v.textContent) : [];
                    const tempLayoutKey = maxTemps ? maxTemps.getAttribute('time-layout') : (minTemps ? minTemps.getAttribute('time-layout') : null);

                    const weatherConditions = parameters.querySelector('weather');
                    const weatherSummaries = weatherConditions ? Array.from(weatherConditions.querySelectorAll('weather-conditions')).map(wc => wc.getAttribute('weather-summary')) : [];
                    const weatherLayoutKey = weatherConditions ? weatherConditions.getAttribute('time-layout') : null;

                    const conditionsIcons = parameters.querySelector('conditions-icon');
                    const iconLinks = conditionsIcons ? Array.from(conditionsIcons.querySelectorAll('icon-link')).map(il => il.textContent) : [];
                    const iconLayoutKey = conditionsIcons ? conditionsIcons.getAttribute('time-layout') : null;
                    
                    const locationForecast = { name: location.name, periods: [] };
                    if (!tempLayoutKey || !timeLayouts[tempLayoutKey]) return null;
                    
                    const numPeriods = timeLayouts[tempLayoutKey].startTimes.length;

                    for (let i = 0; i < numPeriods; i++) {
                        const periodStartDate = timeLayouts[tempLayoutKey].startTimes[i];
                        
                        let currentWeatherSummary = null;
                        let currentIconLink = null;
                        if (weatherLayoutKey && timeLayouts[weatherLayoutKey]) {
                            const weatherIndex = timeLayouts[weatherLayoutKey].startTimes.findIndex(t => t === periodStartDate);
                            if (weatherIndex !== -1) {
                                currentWeatherSummary = weatherSummaries[weatherIndex] || null;
                                currentIconLink = iconLinks[weatherIndex] || null;
                            }
                        }
                        
                        locationForecast.periods.push({
                            summary: timeLayouts[tempLayoutKey].summaries[i],
                            startDate: periodStartDate,
                            endDate: timeLayouts[tempLayoutKey].endTimes[i],
                            highTemp: parseNumericalValue(maxTempValues[i]),
                            lowTemp: parseNumericalValue(minTempValues[i]),
                            weatherSummary: currentWeatherSummary,
                            iconLink: currentIconLink
                        });
                    }
                    return locationForecast;
                } catch (error) {
                    console.error(`Failed to fetch or parse forecast for ${location.name}:`, error);
                    return null;
                }
            }

            function compileAndDisplayRegionalForecast() {
                if (allLocationsForecastData.length === 0) {
                    errorText.textContent = "No forecast data could be loaded for any location.";
                    errorMessage.classList.remove('hidden');
                    return;
                }

                const regionalForecastPeriods = {};
                allLocationsForecastData.forEach(locData => {
                    locData.periods.forEach(period => {
                        const periodDate = new Date(period.startDate);
                        const calendarDayKey = `${periodDate.getFullYear()}-${(periodDate.getMonth() + 1).toString().padStart(2, '0')}-${periodDate.getDate().toString().padStart(2, '0')}`;
                        
                        if (!regionalForecastPeriods[calendarDayKey]) {
                            regionalForecastPeriods[calendarDayKey] = {
                                highs: [], lows: [], weatherSummaries: [], iconLinks: [], summaries: [],
                                startDate: period.startDate
                            };
                        }
                        if (period.highTemp !== null) regionalForecastPeriods[calendarDayKey].highs.push(period.highTemp);
                        if (period.lowTemp !== null) regionalForecastPeriods[calendarDayKey].lows.push(period.lowTemp);
                        if (period.weatherSummary) regionalForecastPeriods[calendarDayKey].weatherSummaries.push(period.weatherSummary);
                        if (period.iconLink) regionalForecastPeriods[calendarDayKey].iconLinks.push(period.iconLink);
                        if (period.summary) regionalForecastPeriods[calendarDayKey].summaries.push(period.summary);
                    });
                });

                const sortedRegionalPeriods = Object.values(regionalForecastPeriods)
                    .map(period => ({
                        startDate: period.startDate,
                        summary: getMostFrequent(period.summaries),
                        avgHigh: period.highs.length > 0 ? Math.round(period.highs.reduce((a, b) => a + b, 0) / period.highs.length) : null,
                        avgLow: period.lows.length > 0 ? Math.round(period.lows.reduce((a, b) => a + b, 0) / period.lows.length) : null,
                        representativeWeatherSummary: getMostFrequent(period.weatherSummaries) || 'Conditions Vary',
                        representativeIconLink: getMostFrequent(period.iconLinks) || 'https://placehold.co/128x128/cccccc/000000?text=No+Icon'
                    }))
                    .sort((a, b) => new Date(a.startDate) - new Date(b.startDate));

                let periodsToDisplay = sortedRegionalPeriods;
                const now = new Date();
                const currentHour = now.getHours(); 

                if (currentHour >= 14) {
                    if (periodsToDisplay.length > 0) {
                        const firstPeriodDate = new Date(periodsToDisplay[0].startDate);
                        const isToday = firstPeriodDate.getDate() === now.getDate() &&
                                        firstPeriodDate.getMonth() === now.getMonth() &&
                                        firstPeriodDate.getFullYear() === now.getFullYear();
                        
                        if (isToday) {
                            periodsToDisplay = periodsToDisplay.slice(1); 
                        }
                    }
                }

                let regionalHtml = `<h2 class="text-2xl font-bold text-blue-800 mb-6 text-center">6-Day Regional Forecast</h2>`;
                regionalHtml += `<div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">`; 

                periodsToDisplay.slice(0, 6).forEach((period, i) => {
                    const avgHighDisplay = period.avgHigh !== null ? `${period.avgHigh}°F` : 'N/A';
                    const avgLowDisplay = period.avgLow !== null ? `${period.avgLow}°F` : 'N/A';
                    
                    regionalHtml += `
                        <div class="card p-4 rounded-lg shadow-sm flex flex-col items-center text-center">
                            <h3 class="text-lg font-bold text-blue-700 mb-1">${formatDate(period.startDate, i === 0)}</h3>
                            <p class="text-gray-600 text-xs mb-2">${period.summary || ''}</p>
                            <img src="${period.representativeIconLink}" alt="${period.representativeWeatherSummary}" class="weather-icon mb-2">
                            <p class="text-md font-semibold text-gray-800 mb-1">${period.representativeWeatherSummary}</p>
                            <div class="flex justify-center items-baseline space-x-2">
                                ${period.avgHigh !== null ? `<p class="text-red-500 text-lg font-bold">Avg H: ${avgHighDisplay}</p>` : ''}
                                ${period.avgLow !== null ? `<p class="text-blue-500 text-lg font-bold">Avg L: ${avgLowDisplay}</p>` : ''}
                            </div>
                        </div>
                    `;
                });
                regionalHtml += `</div>`;

                const regionalCard = document.createElement('div');
                regionalCard.className = 'card regional-forecast-card p-6 rounded-lg shadow-lg flex flex-col';
                regionalCard.innerHTML = regionalHtml;
                forecastGrid.replaceChildren(); 
                forecastGrid.appendChild(regionalCard);
            }

            async function loadAllForecasts() {
                const lastUpdatedElement = document.getElementById('lastUpdated');
                const now = new Date();
                const options = { year: 'numeric', month: 'short', day: 'numeric', hour: 'numeric', minute: '2-digit', timeZoneName: 'short' };
                lastUpdatedElement.textContent = `Last Updated: ${now.toLocaleString('en-US', options)}`;

                loadingIndicator.classList.remove('hidden');
                errorMessage.classList.add('hidden');
                forecastContainer.classList.add('hidden');
                forecastGrid.replaceChildren();
                allLocationsForecastData.length = 0;

                const results = await Promise.all(locations.map(fetchAndParseLocationForecast));

                let hasError = false;
                results.forEach(result => {
                    if (result) {
                        allLocationsForecastData.push(result);
                    } else {
                        hasError = true;
                    }
                });
                
                compileAndDisplayRegionalForecast();

                loadingIndicator.classList.add('hidden');
                forecastContainer.classList.remove('hidden');

                if (hasError) {
                    errorText.textContent = "Some forecast data could not be loaded. Please check the console for details.";
                    errorMessage.classList.remove('hidden');
                }
            }

            // --- Image Generation Logic ---
            generateImageBtn.addEventListener('click', () => {
                const btnText = generateImageBtn.textContent;
                generateImageBtn.textContent = 'Generating...';
                generateImageBtn.disabled = true;

                const originalElement = document.querySelector(".regional-forecast-card");
                
                if (!originalElement) {
                    console.error("Forecast card element not found for capturing.");
                    errorText.textContent = "Could not find the forecast card to generate an image.";
                    errorMessage.classList.remove('hidden');
                    generateImageBtn.textContent = btnText;
                    generateImageBtn.disabled = false;
                    return;
                }

                // --- FIX: Clone the element to capture it off-screen ---
                const clone = originalElement.cloneNode(true);
                clone.style.position = 'absolute';
                clone.style.top = '-9999px';
                clone.style.left = '-9999px';
                document.body.appendChild(clone);

                html2canvas(clone, { 
                    useCORS: true,
                    backgroundColor: '#e0f2f7',
                }).then(canvas => {
                    document.body.removeChild(clone); // Clean up the clone
                    imageOutput.innerHTML = ''; 
                    const img = document.createElement('img');
                    img.src = canvas.toDataURL('image/png');
                    img.className = 'max-w-full h-auto rounded-lg shadow-lg';
                    imageOutput.appendChild(img);
                    imageModal.classList.remove('hidden');
                    
                    generateImageBtn.textContent = btnText;
                    generateImageBtn.disabled = false;
                }).catch(err => {
                    document.body.removeChild(clone); // Ensure cleanup on error
                    console.error("Error generating image:", err);
                    errorText.textContent = "Could not generate the image. Please check the console for details.";
                    errorMessage.classList.remove('hidden');
                    generateImageBtn.textContent = btnText;
                    generateImageBtn.disabled = false;
                });
            });

            closeModalBtn.addEventListener('click', () => {
                imageModal.classList.add('hidden');
            });

            loadAllForecasts();
        });
    </script>
</body>
</html>
